% IF YOU ARE USING OVERLEAF, MAKE SURE TO SET THE COMPILER TO XeLatex (Menu in the top left > Settings > Compiler).

% Gemini theme
% See: https://rev.cs.uchicago.edu/k4rtik/gemini-uccs
% A fork of https://github.com/anishathalye/gemini

\documentclass[final]{beamer}

% ====================
% Packages
% ====================

\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[size=custom,width=91.44,height=60.96,scale=0.9]{beamerposter}
\usetheme{gemini}
\usecolortheme{stanford}
\usebackgroundtemplate{}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=1.17}
\usetikzlibrary{positioning,arrows.meta}

% ====================
% Lengths
% ====================

% If you have N columns, choose \sepwidth and \colwidth such that
% (N+1)*\sepwidth + N*\colwidth = \paperwidth
\newlength{\sepwidth}
\newlength{\colwidth}
\setlength{\sepwidth}{0.025\paperwidth}
\setlength{\colwidth}{0.3\paperwidth}

\newcommand{\separatorcolumn}{\begin{column}{\sepwidth}\end{column}}

% ====================
% Title / author
% ====================

\title{Efficient FSE}

\author{Aayush Gupta\inst{1} \and Mentor: Pulkit/Shubham\inst{1}}

\institute[shortinst]{\inst{1} EE274: Data Compression}

% ====================
% Footer
% ====================

\footercontent{
  EE274: Data Compression \hfill
  \href{https://github.com/aayushg55/stanford_compression_library}{github.com/aayushg55/stanford\_compression\_library} \hfill
  Autumn 2025
}

% ====================
% Logo (optional)
% ====================

\addtobeamertemplate{headline}{}
{
    \begin{tikzpicture}[remember picture,overlay]
      \node [anchor=north east, inner sep=3cm] at ([xshift=0.0cm,yshift=2.5cm]current page.north east)
      {\includegraphics[height=7.0cm]{stanford_logos/Block_S_2_color.png}};
    \end{tikzpicture}
}

% ====================
% Body
% ====================

\begin{document}

\begin{frame}[t]
\begin{columns}[t]
\separatorcolumn

% ====================
% LEFT COLUMN
% ====================

\begin{column}{\colwidth}

  \begin{block}{Problem \& Motivation}
    \begin{itemize}
      \item Modern lossless compressors combine an LZ-style front end with a fast entropy coder (Huffman, range coding, ANS).
      \item Finite State Entropy (FSE), a table-based ANS, underpins Zstandard's entropy stage and achieves near-arithmetic ratios with Huffman-like speed.
      \item \textbf{Goal:} Rebuild FSE in a readable way (Python) then see how far careful engineering can push performance toward production libraries (C++).

    \end{itemize}
  \end{block}

  \begin{block}{How FSE Works}
    \textbf{Core idea:} Maintain a single integer state that always lies in a fixed range. Each symbol occupies a subset of states proportional to its probability.

    \vspace{0.4em}
    \textbf{Table construction (per chunk) (size = $2^{\texttt{tableLog}}$):}
    \begin{enumerate}
      \item \textbf{Normalize counts} so integer frequencies sum to $2^{\texttt{tableLog}}$.
      \item \textbf{Spread symbols} across a state table so symbol $s$ appears $\texttt{freq}[s]$ times.
      \item \textbf{Build decode table:} for each state store $(\texttt{symbol}, \texttt{nbBits}, \texttt{newStateBase})$.
      \item \textbf{Build encode transforms:} per-symbol parameters that reproduce the same state transitions in reverse.
    \end{enumerate}

    \vspace{0.6em}
    \textbf{One decode step:}
    \vspace{-1.0cm}
    \begin{center}
      \begin{tikzpicture}[>=Stealth[scale=1.2], node distance=1.6cm, line width=0.8pt]
        \node[draw, rounded corners, align=center, minimum width=4.2cm] (state) {current state};
        \node[draw, rounded corners, below=of state, align=left, minimum width=15.6cm] (entry)
          {DTable[state] $\rightarrow$ (symbol, nbBits, newStateBase)};
        \node[draw, rounded corners, below=of entry, minimum width=5.8cm] (bits) {read nbBits bits};
        \node[draw, rounded corners, below=of bits, minimum width=5.8cm] (nstate) {$\texttt{newState} = \texttt{newStateBase} + \texttt{bits}$};

        \draw[->] (state) -- (entry);
        \draw[->] (entry) -- (bits);
        \draw[->] (bits) -- (nstate);
      \end{tikzpicture}
    \end{center}

    \begin{itemize}
      \item Each symbol makes the decoder read either $k$ or $k\!+\!1$ bits; the average matches its optimal Shannon code length.
    \end{itemize}

    \textbf{Direction:} Encoder scans symbols backwards, pushing out low bits and updating a single FSE state. Decoder starts from the stored state and walks the decode table forward, reading $nbBits$ each step to recover the original sequence.

    \textbf{Bitstream format:} \texttt{[size][final state][payload]}.


  \end{block}
  
  \begin{block}{References (1/2)}
    \footnotesize
    [1] J. Duda, Asymmetric numeral systems: entropy coding combining speed of Huffman coding with compression rate of arithmetic coding, arXiv, 2013. \url{https://arxiv.org/abs/1311.2540}\par
    [2] Y. Collet, ``Finite State Entropy -- a new breed of entropy coder'' and follow-up posts, Fast Compression Blog. \url{https://fastcompression.blogspot.com}\par
    [3] Y. Collet, FiniteStateEntropy library (FSE), GitHub. \url{https://github.com/Cyan4973/FiniteStateEntropy}
  \end{block}
  % \begin{block}{FSE Core Algorithm: Encoder and Decoder}
  %   \begin{center}
  %     \begin{tikzpicture}[
  %         node distance=1.2cm and 1.8cm,
  %         >=Stealth,
  %         every node/.style={font=\footnotesize},
  %         box/.style={draw, rounded corners, minimum height=0.9cm, align=center}
  %       ]
  
  %       % Encoder row
  %       \node[box, minimum width=2.6cm] (encIn)
  %         {symbols\\$x_0,\dots,x_{n-1}$};
  %       \node[box, right=of encIn, minimum width=3.4cm] (encCore)
  %         {reverse scan\\state + tables\\$\to$ bits + new state};
  %       \node[box, right=of encCore, minimum width=3.8cm] (bitstream)
  %         {bitstream\\[2pt]
  %          [size][final state][payload]};
  
  %       \node[above=0.1cm of encCore] {\textbf{Encoder}};
  
  %       \draw[->] (encIn) -- (encCore);
  %       \draw[->] (encCore) -- (bitstream);
  
  %       % Decoder row
  %       \node[box, below=1.4cm of bitstream, minimum width=3.8cm] (bs2)
  %         {bitstream\\[2pt]
  %          [size][state][payload]};
  %       \node[box, left=of bs2, minimum width=3.4cm] (decCore)
  %         {loop: DTable[state]\\read $nbBits$\\update state};
  %       \node[box, left=of decCore, minimum width=2.8cm] (decOut)
  %         {reconstructed\\symbols};
  
  %       \node[below=0.1cm of decCore] {\textbf{Decoder}};
  
  %       \draw[->] (bs2) -- (decCore);
  %       \draw[->] (decCore) -- (decOut);
  
  %     \end{tikzpicture}
  %   \end{center}
  %   \vspace{-0.4em}
  %   \footnotesize{Encoder scans symbols backwards, pushing out low bits and updating a single FSE state.
  %   Decoder starts from the stored state and walks the decode table forward, reading $nbBits$ each step to recover the original sequence.}
  % \end{block}


\end{column}

\separatorcolumn

% ====================
% MIDDLE COLUMN
% ====================

\begin{column}{\colwidth}

  \begin{block}{Implementation: Python \texorpdfstring{$\rightarrow$}{â†’} C++}
    \textbf{Python FSE (SCL):}
    \begin{itemize}
      \item Implemented in the Stanford Compression Library as a clear, table-based ANS reference.
      \item Uses SCL's \texttt{Frequencies}/\texttt{DataBlock} for modeling, then:
        \begin{itemize}
          \item normalizes counts to $2^{\texttt{tableLog}}$,
          \item runs the FSE spread algorithm,
          \item builds decode and encode tables.
        \end{itemize}
      % \item Block format: \texttt{[block\_size][state\_offset][payload\_bits]} (MSB-first, Python \texttt{BitArray}).
      \item Correct and readable, but far too slow to be a practical codec.
    \end{itemize}

    \vspace{0.4em}
    \textbf{C++ FSE:}
    \begin{itemize}
      \item Reimplements the same core algorithm in C++.
      \item Exposed back to Python via \texttt{pybind} so existing SCL tests and synthetic benchmarks can be reused unchanged.
      \item Implement different levels, corresponding to increasing levels of optimization (ex: LSB bit I/O, chunked bit I/O)
    \end{itemize}
  \end{block}


  \begin{block}{Project Pipeline: Implmentation \& Evaluation}
    \centering

    \begin{tikzpicture}[
      node distance=1.8cm and 3.2cm,
      box/.style={draw, rounded corners, align=center, font=\small,
                  minimum width=3.4cm, minimum height=1.1cm},
      title/.style={font=\bfseries},
      >=Stealth[scale=1.2],
      xshift=-1.5cm,
      yshift=1.4cm
    ]

    
      % Column titles
      \node[title] (codecsTitle) at (-2.0,0.0) {Implementation \& tests};
      \node[title] (shimTitle)   at (8.0,0.0) {Bindings / shims};
      \node[title] (benchTitle)  at (18.0,0.0) {Benchmark harnesses};

      % --- Codecs & core (left) ---

      \node[box, below=0.8cm of codecsTitle] (pyFSE)
        {Python FSE\\(SCL reference)};

      \node[box, below=of pyFSE] (pyTests)
        {Python Test Suite};

      \node[box, below=of pyTests] (cppCore)
        {C++ FSE};

      % --- Bindings & shims (middle) ---

      \node[box, below=0.8cm of shimTitle] (pybind)
        {Pybind module\\\texttt{scl\_fse\_cpp}};

      \node[box, below=of pybind] (shimFull)
        {FSE shim\\for \texttt{fullbench}};

      \node[box, below=of shimFull] (shimLz)
        {FSE shim\\for \texttt{lzbench}};

      % --- Benchmarks (right) ---

      \node[box, below=0.8cm of benchTitle] (pyBench)
        {Python benchmark\\(FSE vs SCL codecs)};

      \node[box, below=of pyBench] (fullbench)
        {\texttt{fullbench}*\\FSE / Huff0};

      \node[box, below=of fullbench] (lzbench)
        {\texttt{lzbench}*\\zstd / zlib / lz4};

      % --- Connections: core <-> Python, bindings, shims ---

      % Core used by pybind and shims
      \draw[->] (cppCore.east) -- (pybind.west);
      \draw[->] (cppCore.east) -- (shimFull.west);
      \draw[->] (cppCore.east) -- (shimLz.west);

      % Tests exercise Python FSE and C++ via pybind
      \draw[->] (pyFSE.south) -- (pyTests.north);
      \draw[->] (pybind.west)      to[out=200, in=20] (pyTests.east);

      % Benchmarks use codecs via bindings/shims
      \draw[->] (pyFSE.east) to[bend left=18] (pyBench.west);
      \draw[->] (pybind.east) to[bend left=10] (pyBench.west);

      \draw[->] (shimFull.east) -- (fullbench.west);
      \draw[->] (shimLz.east)   -- (lzbench.west);

    \end{tikzpicture}
    % \end{center}
    \vspace{-0.4em}
    \footnotesize{*\texttt{fullbench} and \texttt{lzbench} are existing upstream harnesses; my shims register my codec with them.}
  \end{block}
  



  \begin{block}{Benchmarking Setup}
    \begin{itemize}
      \item \textbf{Datasets:} Canterbury and Silesia corpora treated as byte streams (text, binaries, images), plus synthetic distributions.
      \item \textbf{Benchmarks:} Python SCL; C++ \texttt{lzbench} + \texttt{fullbench} (FiniteStateEntropy)
      \item \textbf{Metrics:} compression ratio and encode/decode throughput (MB/s).
    \end{itemize}

    % TODO: Insert small figure for Python SCL benchmarks
    % \begin{figure}[h]
    %   \centering
    %   \includegraphics[width=0.9\linewidth]{figs/python_scl_codecs.pdf}
    %   \caption*{\footnotesize Python SCL codecs: FSE vs Huffman/rANS/tANS (MB/s, compression ratio).}
    % \end{figure}

  \end{block}

  \begin{block}{References (2/2)}
    \footnotesize
    [4] Y. Collet et al., Zstandard compression format and source code, GitHub. \url{https://github.com/facebook/zstd}\par
    [5] Stanford Compression Library (SCL), documentation and entropy coder implementations, GitHub. \url{https://github.com/stanfordcompression/stanford_compression_library}
  \end{block}

\end{column}

\separatorcolumn

% ====================
% RIGHT COLUMN
% ====================

\begin{column}{\colwidth}

  \begin{block}{Preliminary Results}
    \textbf{Python reference (SCL):}
    \begin{itemize}
      \item FSE slower than Huff, faster than rANS/tANS (same compression ratio).
      \item SCL codecs 10-100x slower than zlib/zstd.
    \end{itemize}

    % TODO: Plot 1 (Python SCL codecs)
    % \begin{figure}[h]
    %   \centering
    %   \includegraphics[width=0.9\linewidth]{full_bench_plot.png}
    %   \caption*{\footnotesize Python FSE vs SCL Huffman/rANS/tANS on synthetic and real data.}
    % \end{figure}

    \vspace{0.4em}
    \textbf{C++ FSE:}
    \begin{itemize}
      \item Python $\to$ C++ yields $\sim$20$\times$ speedup and better bit I/O in C++ gives another 2--5$\times$, but still $\sim$2.5$\times$ slower than the target FSE.
    \end{itemize}

    \begin{figure}[h]
      \includegraphics[width=0.70\linewidth]{full_bench_plot.pdf}\\[0.3em]
      \caption{Entropy coder only: my C++ FSE vs Collet's FSE/Huff0 in (\texttt{fullbench}) (synthetic data)}
    \end{figure}

    % TODO: Plot 2 (Entropy-only fullbench)
    % \begin{figure}[h]
    %   \centering
    %   \includegraphics[width=0.9\linewidth]{figs/fullbench_entropy_only.pdf}
    %   \caption*{\footnotesize Entropy-only: my C++ FSE vs Collet's FSE/Huff0/zlibh (\texttt{fullbench}).}
    % \end{figure}



    \vspace{-0.75em}
    \begin{itemize}
      \item \textbf{lzbench:} My FSE trails in throughput and compression significantly (those codecs add powerful LZ front ends to already optimized entropy stages).
    \end{itemize}

    \vspace{-1em}
    \begin{figure}[h]
      \centering
    
      \begin{minipage}{0.49\linewidth}
        \centering
        \includegraphics[width=\linewidth]{encode.pdf}\\[0.3em]
      \end{minipage}
      \hfill
      \begin{minipage}{0.49\linewidth}
        \centering
        \includegraphics[width=\linewidth]{decode.pdf}\\[0.3em]
      \end{minipage}
    
      \caption{Throughput vs compression ratio on the Silesia corpus (\texttt{lzbench}). Each point represents a different file in the corpus.}
    \end{figure}


    % \begin{center}
    %   \includegraphics[width=0.5\linewidth]{encode.pdf}\\[0.3em]
    %   {\footnotesize Silesia corpus: Encode throughput  vs compression ratio}
    % \end{center}

    % \begin{center}
    %   \includegraphics[width=0.5\linewidth]{decode.pdf}\\[0.3em]
    %   {\footnotesize Silesia corpus: Decode throughput  vs compression ratio}
    % \end{center}

    % TODO: Plot 3 (lzbench end-to-end)
    % \begin{figure}[h]
    %   \centering
    %   \includegraphics[width=0.9\linewidth]{figs/lzbench_end_to_end.pdf}
    %   \caption*{\footnotesize \texttt{lzbench}: my FSE shim vs zstd/zlib/lz4 on Silesia/Canterbury.}
    % \end{figure}

  \end{block}

  \vspace{-1em}
  \begin{block}{Next Steps}
    \begin{itemize}
      \item Per-block headers are large (1KB histogram) $\to$ NCount compression.
      \item Encoding/decoding multiple streams in parallel ("loop unrolling")
      \item Better handling of low frequency symbols
      \item Adaptive table sizes
      \item Further reduce bitreader/bitwriter overhead
    \end{itemize}
  \end{block}

\end{column}

\separatorcolumn
\end{columns}
\end{frame}

\end{document}
